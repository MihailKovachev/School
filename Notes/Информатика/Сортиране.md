1. Bubble Sort (метод на мехурчето)
	
	**а) алгоритъм**
	
	**б) имплементация**

```java
void bubbleSort(int[] arr) {
	for (int i = 0; i < arr.length - 1; ++i) {
		for (int j = 0; j < arr.length - i - 1; ++j)} {
			if (arr[j] > arr[j+1]) {
				swap(arr[j], arr[j+1])
			}
		}
	}
}
```
	
2. Selection Sort (метод на пряката селекция)
	
	**а) алгоритъм**
	- намира се най-малкият елемент от масива и се поставя на първо място
	- намира се най-малкият елемент от остатъка от масива и се поставя на второ място и така нататък
	
	**б) имплементация**

```java
void selection_sort(int[] arr) {
	for (int i = 0; i < arr.length; ++i) {
		int min_index = i;
		
		for (int j = i+1; j < arr.length; j++) {
			if (arr[j] < arr[min_index]) {
				min_index = j;
			}
			
			int temp = arr[i];
			arr[i] = arr[min_index];
			arr[min_index] = temp
		}
	}
}
```

3. Insertion Sort

```java
void insertionSort(int array[]) {
    int size = array.length;

    for (int step = 1; step < size; step++) {
      int key = array[step];
      int j = step - 1;
      
      while (j >= 0 && key < array[j]) {
        array[j + 1] = array[j];
        --j;
      }
      
      array[j + 1] = key;
    }
  }
```

4. Merge Sort
	
	**а) алгоритъм**
	- масивът с $n$ елемента се разделя на два масива
	- тези два масива се разделят на по още едва
	- това продължава рекурсивно докато оригиналният масив не се сведе до $n$ масива с по един елемент
	
	**б) имплементация**
	
```java
void mergeSort(int[] arr) {
	if (arr.length <= 1) return;
	
	// Split the array into two subarrays
	int[] firstHalf = new int[arr.length / 2];
	int[] secondHalf = new int[arr.length - arr.length / 2];
	
	// Populate the two subarrays
	System.arraycopy(arr, 0, firstHalf, 0, arr.length / 2);
	System.arraycopy(arr, arr.length / 2, secondHalf, 0, arr.length - arr.length / 2);
	
	// Sort the two subarrays 
	mergeSort(firstHalf);
	mergeSort(secondHalf);
	
	// Merge the two subarrays 
	merge(firstHalf, secondHalf, arr);
}

void merge(int[] leftArr, int[] rightArr, int[] outArr) {
	int outIndex = 0, int leftIndex = 0, int rightIndex = 0;
	while (leftIndex < leftArr.length && rightIndex < rightArr.length) {
		if (leftArr[leftIndex] <= rightArr[rightIndex])
		{
			outArr[outIndex] = leftArr[leftIndex];
			outIndex++;
			leftIndex++;
		}
		else {
			outArr[outIndex] = rightArr[rightIndex];
			outIndex++;
			rightIndex++;
		}
	}
	while (leftIndex < leftArr.length) {


}
```

5. Quick Sort
	
	**а) алгоритъм**
	- избира се един елемент, наречен "pivot"
	- всички елементи, които са по-малки от pivot-а, се слагат отляво на него, а всички по-големи - отдясно
	- двата подмасива, които са разделени от pivot-а, се сортирст рекурсивно по аналогичен начин
	
	**б) имплементация**

```java
void quickSort(int[] arr, int startIndex, int endIndex) {
	if (endIndex <= startIndex) { return; }
	
	int pivot = arr[endIndex];
	
	int leftIndex = startIndex;
	int rightIndex = endIndex;
	while (leftIndex < rightIndex) {
		while(arr[leftIndex] <= pivot && leftIndex < rightIndex) {
			leftIndex++;
		}
		while(arr[rightIndex] >= pivot && leftIndex < rightIndex) {
			rightIndex--;
		}
		
		swap(arr, leftIndex, rightIndex);
	}
	
	swap(arr, leftIndex, endIndex); // put the pivot in place
	
	quickSort(arr, startIndex, leftIndex - 1);
	quickSort(arr, leftIndex + 1, endIndex);
}

void swap(int[] arr, int index1, int index2) {
	int temp = arr[index1];
	arr[index1] = arr[index2];
	arr[index2] = temp;
}
```